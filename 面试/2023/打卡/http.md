# 三次握手

http 虽然是无状态的，但其是基于 tcp 协议传输数据，tcp 是有状态的，发送请求之前需要先建立连接，而三次握手就是指建立一个 tcp 连接时，需要客户端和服务器总计发送 3 次请求来确认双方的发送和接收能力正常，同时指定自己的初始化序列号，为后续传输数据做准备

开始时客户端处于 Closed 状态，服务端处于 Listen 状态。因为是客户端需要获取数据，所以首次握手由客户端发起

第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SEND 状态

第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也指定自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 状态

第三次握手：客户端收到 SYN 报文之后，同样会把服务器的 ISN + 1 作为 ACK 的值，发送一个 ACK 报文，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态，服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，至此，双方已成功建立连接

## 有关状态

SYN 报文是用来同步状态的，ACK 报文是用来应答的

LISTEN：侦听来自客户端 tcp 端口的连接请求
SYN-SENT：在发送连接请求后等待匹配的连接请求
SYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认
ESTABLISHED：代表一个打开的连接，数据可以传送给用户

### 为什么需要握手三次？

三次是双方明确连接建立成功所需的最少次数

就好像 a 和 b 打电话：
a：喂，能听到么？（第一次握手）
b：能，你能听到我么？（第二次握手）
a：可以，周末出来吃饭啊？（第三次握手）

## 四次挥手

tcp 连接的断开需要发送四个包，因此称为四次挥手，客户端或服务器均可主动发起挥手动作，发起挥手时双方都处于 ESTABLISHED 状态，假如客户端率先发起挥手

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号，此时客户端处于 FIN_WAIT1 状态

第二次挥手：服务端收到 FIN 之后，会把客户端的序列号值+1 作为 ACK 报文的序列号值，发送一个 ACK 报文，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。tcp 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2 状态，等待服务端发送连接释放报文

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送 FIN 报文，并指定一个序列号，此时服务端处于 LAST_ACK 状态

第四次挥手：客户端收到 FIN 之后，作为应答，也会以服务端的序列号值+1 作为自己 ACK 报文的序列号值，发送一个 ACK 报文，此时客户端处于 TIME_WAIT 状态

服务端收到 ACK 报文之后，就会关闭连接，变成 CLOSED 状态。而客户端会等待 2MSL 确保服务端收到自己的 ACK 报文后再关闭连接，变成 CLOSED 状态

## 半关闭状态

指 tcp 的一端在断开了与另一端的连接后还可以拥有接收来自另一端数据的能力（因为另一端和当前这一端的连接并没有断开）

## MSL

Maximum Segment Lifetime，报文最大生存时间/最长报文段寿命，指任何 tcp 报文在网络上存在的最长时间，超过这个时间报文将被废弃

## 为什么第四次挥手之后客户端需要等待 2MSL 时长再关闭

保证客户端发送的最后一个 ACK 报文能够顺利到达服务端，因为网络传输有可能是不稳定的，这个 ACK 报文段有可能丢失，使得服务端收不到来自客户端的 FIN+ACK 报文段的确认，这种情况下服务器会认为客户端发送报文超时并且重新传 FIN+ACK 报文段，而客户端是可以在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，客户端就会重新发送最后一个 ACK 报文（服务器没收到 ACK 会认为超时，并且尝试重复第三、第四次挥手），而如果客户端发送完最后一个 ACK 之后没有等待直接关闭，一旦出现超时情况，服务器尝试重新关闭就没办法得到客户端的响应，这会导致服务端无法正常关闭

# http 各版本的区别

## http 各版本差异

### 1.0

1. 新增 HEAD、POST 方法
2. 新增响应状态码
3. 引入了协议版本号的概念
4. 引入了 HTTP Header（头部）的概念，可灵活扩展
5. 传输数据不再仅限于文本

### 1.1

1. 新增 PUT、DELETE 方法
2. 新增缓存机制
3. 默认采用持久连接 Connection: keep-alive
4. 允许响应数据分块（chunked），利于传输大文件
5. 强制要求 Host 头

### http 2

1. 利用 "HPACK" 算法压缩头部，减小传输体积
2. 以二进制格式传输数据
   将原来的 "Header + Body" 的消息 "打散" 为一个个的 二进制帧，用 "HEADERS" 帧存放头数据，"DATA" 帧存放实体数据

http2 为此定义了一个 "流" 的概念，他是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID，帧是有先后顺序的，最终这些数据帧会按次序组装成真正的报文信息

因为将数据传输拆解为细小的"帧"颗粒，所以 http2 可以在一个 tcp 连接上用 "流" 同时发送多次往返通信的数据，这就是 "多路复用"

3. 服务器推送：服务端可以主动向客户端发送请求

4. http2 强化了安全方面，要求下层协议必须是 TLS1.2 以上

## 常见状态码

### 1XX

表示目前是协议处理的中间状态，还需要后续的操作

1. 100 继续
2. 101 协议升级 upgrade （http -> websocket）

### 2XX

成功，报文已经收到并被正确处理

1. 200 成功
2. 204 成功，但响应头后没有 body 数据
3. 206 成功，但 body 中的数据是资源的一部分，后续还需要继续请求，适用于大文件分块传输或断点续传

### 3XX 重定向

1. 301 永久重定向
2. 302 临时重定向
3. 304 配置缓存时才会返回，表示当前客户端拥有的资源是最新的，无需重新请求，直接用本地的就行

### 4XX 客户端错误

1. 400 请求报文错误，但没有具体原因，可能是数据格式错误、缺少请求头或者 URL 超长
2. 401 身份未验证
3. 403 身份验证了，未通过
4. 404 没有这个服务（通常是接口没在这个环境上部署）
5. 405 接口不支持当前的请求方法类型，比如不允许 post，只能 get

### 5XX 服务器错误

1. 500 服务器错误
2. 502 网关错误
3. 503 服务器繁忙，无法响应服务（环境崩了）
4. 504 网关超时

# header 常见状态码

## 请求头

1. Accept：表示浏览器可以接受服务器返回的文件类型，或者说浏览器支持解析哪些文件类型 （如 text/html）
2. Accept-Encoding：表示浏览器支持的编码方法，通常指压缩方法（如 gzip）
3. Connection：连接方式
   · keep-alive：持久连接，多个请求会重复使用同一个 tcp 连接，减少每次请求前都需要 tcp 建立连接的开销
   · close：短连接，相当于告诉服务端本次请求之后就断开连接。这种情况下再次获取请求时会重新建立连接
4. User-Agent：客户端当前使用的浏览器厂商信息
5. Host：表示请求将要发送到的服务器主机名和端口号（1.1 之后强制携带）
6. Referer：包含了当前请求页面的来源页面的地址（即从哪个页面的链接进到当前页面的）
7. Cookie：携带由 set-cookie 下发的信息（主要是用户信息），解决 http 无状态的身份认证问题
8. Cache-Control：设置缓存策略
9. Range：用于范围请求数据（断点续传），指定第一个字节和最后一个字节的位置，表示获取资源的哪一部分（例：Range:bytes=0-1024）
10. Accept-Ranges: bytes，表示客户端支持范围请求数据，为 none 时表示不支持，此时服务器只能返回完整数据

### 队头阻塞

当 Connection 设置为 keep-alive 时会出现，当前的请求耗时过长导致后面排队的请求等待

#### 解决办法

http1.1 其实没有办法彻底解决阻塞的问题，只能通过多开并发连接来缓解

1. 并发连接

开启多个并发请求（浏览器最大连接数，chrome 是 6 个）

2. 域名分片

通过开启多个子域名，最终映射到同一个域名的方法实现增加并发请求数量

## 响应头

1. Cache-Control：设置缓存策略
2. Content-type：告诉客户端实际返回资源的类型
3. Content-Encoding：告诉客户端返回资源的编码类型
4. Date：服务端发送资源时的服务器时间，以格林尼治所在地的标准时间为准，以解决不同时区互相请求资源时时间混乱的问题
5. Server：当前使用的服务器类型和对应的版本
6. Connection：当前 tcp 连接方式
7. Transfer-Encoding：处理范围数据请求时，采用的编码格式，常见为 chunk
8. Content-Range：对应请求头的 Range，指返回的数据属于全部资源的哪一段

9. Access-Control-Allow-Origin：表示允许跨域请求的网站，为 \* 时表示所有网站均可跨域
10. Access-Control-Allow-Methods：表示允许跨域请求的方法
11. Access-Control-Allow-Credentials：是否允许发送 Cookie，默认 CORS 请求不携带 Cookie。设置为 true 则携带 Cookie。Access-Control-Allow-Origin 为 \* 时，必须为 true
12. Set-Cookie：向客户端发送 Cookie
13. Content-Length：表示当前返回的资源大小

# 跨域

## 同源策略

浏览器的一种安全策略，限制了从一个源加载的文档或脚本如何与另一个源进行交互

满足同源：域名、端口、协议一致

## 同源策略的限制

1. Cookie、LocalStorage、IndexDB 等存储性内容
2. 操作 DOM
3. ajax 同源可读写，跨域请求会被拦截
4. iframe 同源可读写，访问跨域页面只读

## 支持跨域的三种标签

1. <script src='xxx'>
2. <link href='xxx'>
3. <img src='xxx'>

## 跨域方法

### jsonp

原理就是利用 script 标签不受同源策略的限制，属于异步请求

· 优点：简单、兼容性好
· 缺点：只支持 get 请求，容易被 XSS 攻击

### CORS

后端设置 Access-Control-Allow-Origin 以开启 CORS 跨域。虽然 CORS 和 前端没有直接关联，但以这种方式解决跨域时请求会分为简单请求和复杂请求

1. 使用 GET、HEAD、POST 方法
2. Content-Type 属于以下三种之一：
   · text/plain
   · multipart/form-data
   · application/x-www-form-urlencoded

同时满足 1、2 两个条件，就属于简单请求，否则属于复杂请求，对于复杂请求在真正发送请求之前要先发送一个 options 请求来询问服务端是否允许跨域

### nginx 反向代理

配置中转 nginx 服务器来反向代理服务端，可以改写 cookie。支持所有浏览器，无代码改动，不会影响服务器性能

### postMessage

postMessage 允许不同源脚本通过异步的方式实现通信，可实现当前页面和新打开页面、多页面、当前页面与嵌套 iframe 的跨域通信

# Cookie

Cookie 是服务端委托浏览器存储在客户端的一些数据，这些数据通常会记录用户的关键识别信息。主要是为了解决 http 无状态带来的身份认证问题

客户端首次向服务器发送请求时，服务器会通过 Set-Cookie 响应头将 Cookie 数据传回，客户端再次发送请求时，就会通过 Cookie 请求头携带这些
数据发送给服务器

## Set-Cookie 其他功能

1. 设置 Cookie 的作用域

通过 Domain 和 Path 指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URL 中提取出 host 和 path 部分，对比 Cookie 的属性，如果不满足条件，就不会在请求头里发送 Cookie。不能跨域设置 Cookie，比如在 taobao.com 下把 Domain 设置成 baidu.com 是无效的

2. 设置 Cookie 的生命周期（即有效期，让其只能在一段时间内可用，一旦超过有效期浏览器会认为 Cookie 失效，从存储中删除，不会发送给服务器）

Expires：绝对时间
Max-age：相对时间

3. Secure

Secure 表示当前 Cookie 只能用 https 协议加密传输，明文的 HTTP 协议禁止发送。但 Cookie 本身不是加密的，在浏览器中还是以明文的形式存在

### 安全相关

1. HttpOnly

HttpOnly 属性会告诉浏览器，当前 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问。浏览器的 js 引擎就会禁用 document.cookie 等可以读写 Cookie 的 api，可以有效防范 XSS 攻击

2. SameSite

SameSite 属性可以限制 Cookie 在跨站请求中的传递，进而防止跨站请求伪造（CSRF）

chrome80 版本默认将 SameSite 设置为 lax，限制了 post 表单、iframe、ajax、image 以及 script 情况下 Cookie 的发送

# 缓存

客户端和服务器通过 Cache-Control 字段来约定当前资源的缓存策略

## Cache-Control

### 做响应头时

1. no-store：不允许缓存（比如秒杀页面）
2. no-cache：可以缓存，但缓存之前必须要去服务器验证是否过期，是否有最新的版本（no-cache 相当于）
3. must-revalidate：表示如果当前缓存没过期的话就可以继续使用，如果过期了还想用就必须去服务器验证
4. max-age：表示缓存的有效时间，单位是秒。时间的计算起点是从响应报文的创建时刻（也就是离开服务器的时刻）开始算，而不是客户端收到报文的时刻，也就是说包含了网络请求过程中的耗时

### 做请求头时

1. 可以通过 Cache-Control:max-age = 0 来获取最新的资源

## 强缓存

缓存有效时间内客户端对于这个资源的请求不会和服务器有交互

1. max-age
2. Expires：绝对时间，以格林尼治所在地的标准时间为准（有 GMT 就是格林尼治时间，例：Wed, 21 Oct 2015 07:28:00 GMT）

max-age 优先级大于 Expires，两者同时存在时 Expires 会被忽略

## 协商缓存

客户端对于该资源的请求会先询问服务端当前缓存是否过期

### 请求头

1. If-Modified-Since：携带 Last-modified 时间
2. If-None-Match：携带 ETag

### 响应头

1. Last-modified：提供资源最后一次的修改时间，绝对时间

Last-modified 是秒级的，如果一个文件在一秒内更改了多次，这一秒内的新版本无法区分（不太可能吧？）。再者，如果文件定期更新，但内容有可能没有变化，这种场景 Last-modified 无法分辨

2. ETag：资源唯一标识

ETag 有强、弱之分，强 ETag 要求资源在字节级别必须完全一致；弱 ETag 在值前面有 W/标记，只要求资源在语义上没有变化，但内容可能会发生改变（如果 html 中标签调整顺序，或者多了几个空格）
