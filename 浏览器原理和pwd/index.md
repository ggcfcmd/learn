# 浏览器原理和 PWA

1. CPU（Central Processing Unit）

中央处理器，主要功能是解释计算机指令以及处理计算机软件中的数据。串行地一件接一件地处理交给他的任务，在现代电脑上一般有多个核心，4 core、8 core，'核' 是物理上的概念，表示硬件上真正存在几个核心

2. GPU（Graphics Processing Unit）

图形处理器，单个 GPU 只能处理简单的任务，但数量非常多，故并行计算能力很强

3. 进程 & 线程

进程：CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
线程：CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）

当执行一个应用程序的时候，操作系统会为此程序分配一个进程，会有一块独立的内存空间，当进程结束的时候，此内存空间会被释放掉

## 浏览器架构

Browser Process（全局只有一个）：负责浏览器主体部分，包括导航栏；书签；前进、后退按钮
Network Process（全局只有一个）：网络进程，负责页面的网络资源加载
GPU（全局只有一个）：图像渲染进程，用于绘制页面
Q: 为什么 GPU 要单独拆分为一个进程？因为不同的 tab 是有不同的渲染进程，gpu 需要接收这些进程的请求并且绘制页面，所以需要存在独立于这些渲染进程之外的地方
Renderer（多个）：渲染进程，标签页内和网页展示相关的所有工作，将 html css js 转换为用户可以交互的网页，**默认情况**下每个 tab 有一个独立的渲染进程

Q：什么情况下会有多个渲染进程呢？ 见下方网站隔离

Plugin（多个）：插件进程

其他进程：工具进程、辅助框架等

### 多进程架构的好处是什么？

1. 容错性

不同的 tab 拥有不同的渲染进程，彼此内存相互独立，一个 tab 挂掉不会影响其他的 tab 进程运行

2. 安全性和沙盒性

所有的 js 代码其实都跑在渲染进程中，但浏览器不希望用户可以拥有太多修改底层逻辑的能力，所以浏览器需要限制渲染进程的能力，让其只有渲染和绘制页面的能力

3. 每个进程可以拥有更多的内存

因为每个进程都会分配一块独立的内存空间

### 多进程架构的坏处是什么？

一些基础的东西（比如 V8 Javascript 引擎），会在不同进程的内存空间中同时存在，所以就消耗了一些不必要的内存

- Chrome 如何优化这种情况？
  · 限制启动的进程数目，当启用的进程数达到上限后，访问同一域名的 tab 都会放在同一个进程里

- Chrome 的服务化

所谓服务化就是将浏览器本身相关的部分拆分为一个个不同的服务（比如 browser process 分为 UI thread、network thread、storage thread），服务化之后，这些功能既可以放在不同的进程里面运行也可以合并为一个单独的进程运行，这样做的好处是让 Chrome 在不同性能的硬件上可以有不同的表现，当运行在一些性能比较好的硬件时，浏览器进程相关的服务就会被放在不同的进程运行以提高系统的稳定性。相反如果当前运行的硬件性能不好，这些服务就会被放在一个进程里来执行以减少内存的占用（相当于是第一种多进程注册服务的降级版，优先保证 chrome 浏览器可以正常使用）

### 网站隔离

iframe

当一个 tab 页存在跨站的 iframe，那么这个 iframe 会拥有独立的渲染进程（否则可能会违背同源策略）

### 导航时究竟发生了什么？

1. url 解析
2. dns 查询
3. 建立 tcp 连接
4. 发送 http 请求
5. 接收 http 响应请求
6. 页面渲染
   1. 解析 html，构建 dom 树
   2. 解析 css，构建 css 规则树
   3. 合并 dom 树和 css 规则树，生成 render 树
   4. 布局 render 树，进行各种元素尺寸的计算
   5. 绘制 render 树
   6. 浏览器将各层的信息发送给 GPU，GPU 将各层合成，显示在屏幕上

### 处理输入（1）

通过 UI 线程（浏览器进程的一部分，控制浏览器上的按钮及输入框）来判断输入的内容是关键词还是 url

### 开始导航（2、3、4）

当用户按下回车键的时候，UI 线程会通知网络进程来初始化一个网络请求（DNS 解析、建立 TCP 连接），获取站点资源

- 301

网络进程会通知 UI 线程进行重定向，然后再发起一个网络请求

### 读取响应（5）

1. 响应类型的判断

Content-Type：application/json

2. 不同响应类型的处理

- html 浏览器会将获取到的数据交给渲染进程
- 压缩文件/其他类型 会交给下载管理器来处理

3. 安全检查

在把数据交给渲染进程之前进行

比如域名是否和已有病毒页面匹配 或者检查是否是跨站数据

### 寻找一个渲染进程来绘制页面

网络进程确认响应资源安全并做完所有处理之后，会通知 UI 线程来为其分配一个渲染进程

Q：网络请求的耗时是不固定的，如果耗时比较久的话，UI 线程会持续等待么？

在网络请求的过程中，UI 线程会提前创建一个渲染进程做准备

- 如果一切顺利，那么就直接用这个渲染进程工作
- 如果发生重定向或者安全问题，那么准备好的这个渲染进程会被舍弃掉，重新开启一个渲染进程

### 提交导航

由渲染进程提交，代表准备加载页面

### 加载完成

当渲染进程完成渲染，load，会通过 IPC 告诉浏览器进程，让 UI 线程停止导航栏/tab 上的转圈

## 渲染进程中具体做了什么？

1. 构建 dom

渲染进程接收 html 文本数据，并把其转换为 dom 对象

2. 加载子资源（图片、css、js）

3. js 会阻塞 html 的解析过程么？

### 样式计算

主线程会解析页面的 css 来确定每个 dom 节点的计算样式

### 布局 layout

1. 主线程会遍历刚刚构建的 dom 树，根据 dom 节点的计算样式来计算出一个布局树
2. 布局树上的每个节点会有它在页面上的 x，y 坐标，以及盒子大小的具体信息（只有可见的节点信息）

display：none（不在布局树上）
visibility：hidden（在布局树上）
