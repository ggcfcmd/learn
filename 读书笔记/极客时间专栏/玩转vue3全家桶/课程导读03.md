# Vue2 的历史遗留问题

## 类型校验

从开发维护的角度看，Vue2 是使用 Flow.js 做类型校验，但 Flow.js 目前已经停止维护了，当前社区以 TypeScript 构建基础库为主流

## 跨端问题

Vue2 内部运行时，是直接执行浏览器 API 的，基于这种实现，在跨端场景下，要么直接进入 Vue 源码中，和 Vue 一起维护，如 Weex；要么直接复制一份全部 Vue 的代码，把浏览器 API 换成客户端或者小程序的，如 mpvue，但很难享受到 Vue 后续的更新，需定期更换复制的全量代码

## 响应式原理

Vue2 响应式是基于 Object.defineProperty()实现的，并不是真正的代理，而是对于某个属性的拦截，其无法拦截不存在的属性，所以 Vue2 中所有数据必须要在 data 里声明。并且有些场景无法监听：如对数组长度的修改操作（底层写 polfill、$set），删除数据（需要$delete API 辅助）

## Option API 在组织代码较多组件时不易维护

对于 Option API 来说，所有的 methods、computed 都在一个对象里配置，体量比较大的组件开发过程中会不太好维护

# Vue3 新特性

## RFC（Request For Comments） 机制

关于 Vue 的新语法或新功能的讨论，都会先在 GitHub 上公开征求意见，邀请社区的人一起讨论，这会让 Vue 社区更加有活力，生态更加开放

## 响应式系统

Vue2 响应式见上方[响应式原理]

Vue3 Proxy()

优点：真正的代理，拦截整个对象，并且可以监听更多的数据格式，如 Set、Map。在 Proxy 之前，前端无法完整的监听一个 JavaScript 对象的变化，只能借助 Object.defineProperty()去实现基本'等价'的功能

缺点：兼容性不好，不兼容 IE11 以下的浏览器

## 自定义渲染器

没太读懂

## 所有模块使用 TypeScript 重构

强类型语言，将部分运行阶段的报错在编译阶段暴露；提示更方便，代码更健壮

## Composition API

demo见课程导读03demo.html

Vue2 Options API
优点：代码直观，模块划分清晰
缺点：
· 所有数据都挂载在this之上，因而Options API的写法对TypeScript的类型推导并不友好，也不好做Tree-shaking（移除JavaScript上下文中的未引用代码）清理代码
· 新增功能基本都需要更改data、method等配置，面条式代码，行数上去之后开发时反复上下切换，不好维护
· 代码复用性差，Vue2的组件很难抽离通用逻辑，只能使用mixin，还可能会有命名冲突的问题

Vue3 Composition API
缺点：代码不直观，看起来繁琐
优点：
· 所有API都是通过import引入，对Tree-shaking很友好，代码中没用到的功能，打包时会被清理掉，减少包的大小
· 可以将一个功能模块的methods、data写在一起，不用上下反复横跳
· 代码方便复用，可以把一个功能所有的methods、data封装在一个独立的函数里，便于复用
· 新增的return等语句，在实际项目中使用<script setup></script> 特性可以清除

## 新的组件
Fragment：Vue3组件不再要求有一个唯一的根节点，清除很多无用的占位div
Teleport：允许组件渲染在别的元素内，开发弹窗组件时特别有用
Suspense：异步组件，更方便开发有异步请求的组件

## 工程化工具 Vite
Vite是一款可以大幅度优化开发体验的工程化工具，并不和Vue强关联，其竞品是Webpack。Webpack等工程化工具的原理是根据你的import依赖逻辑，形成一个依赖树，然后调用对应的处理工具，把整个项目打包后，放在内存里再启动调试，由于要预打包，对于大型项目启动调试环境往往需要几分钟。现代浏览器已经默认支持了ES6的import语法，Vite就是基于这个原理实现的：在调试环境下不需要全部预打包，只是把首页依赖的文件依次通过网络请求去获取，提升开发体验，做到了复杂项目的秒级调试和热更新