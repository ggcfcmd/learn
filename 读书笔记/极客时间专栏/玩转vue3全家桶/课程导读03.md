# Vue2 的历史遗留问题

## 类型校验

从开发维护的角度看，Vue2 是使用 Flow.js 做类型校验，但 Flow.js 目前已经停止维护了，当前社区以 TypeScript 构建基础库为主流

## 跨端问题

Vue2 内部运行时，是直接执行浏览器 API 的，基于这种实现，在跨端场景下，要么直接进入 Vue 源码中，和 Vue 一起维护，如 Weex；要么直接复制一份全部 Vue 的代码，把浏览器 API 换成客户端或者小程序的，如 mpvue，但很难享受到 Vue 后续的更新，需定期更换复制的全量代码

## 响应式原理

Vue2 响应式是基于 Object.defineProperty()实现的，并不是真正的代理，而是对于某个属性的拦截，其无法拦截不存在的属性，所以 Vue2 中所有数据必须要在 data 里声明。并且有些场景无法监听：如对数组长度的修改操作（底层写 polfill、$set），删除数据（需要$delete API 辅助）

## Option API 在组织代码较多组件时不易维护

对于 Option API 来说，所有的 methods、computed 都在一个对象里配置，体量比较大的组件开发过程中会不太好维护

# Vue3 新特性

## RFC（Request For Comments） 机制

关于 Vue 的新语法或新功能的讨论，都会先在 GitHub 上公开征求意见，邀请社区的人一起讨论，这会让 Vue 社区更加有活力，生态更加开放

## 响应式系统

Vue2 响应式见上方[响应式原理]

Vue3 Proxy()

优点：真正的代理，拦截整个对象，并且可以监听更多的数据格式，如 Set、Map。在 Proxy 之前，前端无法完整的监听一个 JavaScript 对象的变化，只能借助 Object.defineProperty()去实现基本'等价'的功能

缺点：兼容性不好，不兼容 IE11 以下的浏览器

## 自定义渲染器

没太读懂

## 所有模块使用 TypeScript 重构

强类型语言，将部分运行阶段的报错在编译阶段暴露；提示更方便，代码更健壮

## Composition API
