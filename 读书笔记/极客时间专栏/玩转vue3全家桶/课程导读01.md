# Angular1、Vue1、React 框架间响应式的原理

· Angular1
脏检查：指每次用户交互时都检查一次数据是否发生变化，有变化就去更新 DOM

· Vue1
响应式：初始化的时候为数据的每一个属性创建一个 Watcher 用以监听数据变化，当变了的时候就能精确地知道数据的哪个 key 变了，去针对性修改对应的 DOM 即可

· React
虚拟 DOM：利用一个 JavaScript 对象来描述整个 DOM 树，可以方便的通过虚拟 DOM 计算出变化的数据

## Vue 和 React 的对比

Vue 框架中如果数据发生变化，框架会主动告诉你修改了哪些数据；而 React 数据变化后，只能通过新旧数据的计算 Diff 来得知数据的变化

### 各自的性能问题及解决办法

· Vue
对于 Vue 来说，其核心之一就是 "响应式"，即数据变化后会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个数据都有一个 watcher 会影响性能

优化方案：Vue1 的问题在于响应式数据过多，过分占用内存，Vue2 采用虚拟 DOM 和响应式结合的方式，组件之间的变化，通过响应式来通知更新，组件内部的数据变化，通过虚拟 DOM 去更新页面，以此将响应式的监听器控制在了组件级别，虚拟 DOM 的量级也控制在组件大小，同时虚拟 DOM 也为 Vue 带来了跨端的能力。Vue3 更是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到了按需更新

· React
对于 React 中虚拟 DOM 的 Diff 算法而言，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6ms（1000 / 60），那么就有可能造成性能的卡顿

优化方案：借鉴了操作系统时间分片的概念，引入了 Fiber 架构，将整个虚拟 DOM 树微观化，变成链表，然后利用浏览器的空闲时间计算 Diff。一旦浏览器有需求，就可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲（虽然没有减少运算量，但利用浏览器空闲实现计算，进而解决卡顿问题）
