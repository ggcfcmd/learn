# 概念

基于 single-spa 二次开发的微前端解决方案

## 功能点

1. JS 隔离
2. CSS 隔离
3. 父子应用通讯
4. 应用间资源共享
5. 预加载
6. 子应用并行
7. 按需加载

## 相比于 single-spa 的优势

single-spa 总体只做了两件事，加载微应用（加载方法需要用户自己来提供）、维护微应用状态（初始化、挂载、卸载）

1. single-spa 对于子应用的入侵性比较强，采用 js-entry 的方式做微应用的输出（就是将整个微应用打包成一个 JS 文件），这会导致按需加载、首屏资源加载优化、css 独立打包等常见打包优化策略都没法做了。qiankun 采用 html-entry 的方式，保留了优化的口子

2. 样式隔离

single-spa 没做，qiankun 有两种实现方式，第一种是为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响，是比较严格的样式隔离模式；第二种是实验性的方式，通过动态改写 css 选择器来实现，可以理解为 css scoped 的方式

3. 运行时沙箱

single-spa 没做，qiankun 的运行时沙箱分为 js 沙箱和样式沙箱。js 沙箱为每个微应用生成单独的 window proxy 对象，配合 html entry 提供的 js 脚本执行器来实现 js 隔离；样式沙箱通过重写 DOM 操作方法，来劫持动态样式和 js 脚本的添加，让样式和脚本添加到正确的地方（即主应用的资源插入到主应用模板内，微应用的资源插入到微应用模板内），并且劫持的动态样式做了 scoped css 处理，为劫持的脚本做了 js 隔离的处理

4. 资源预加载

qiankun 实现预加载的思路有两种，一种是当主应用执行 start 方法启动 qiankun 以后立即去预加载微应用的静态资源；另一种是在第一个微应用挂载以后预加载其他微应用的静态资源，这部分利用 single-spa 提供的 single-spa:first-mount 事件来实现

5. 应用间通信

single-spa 没做，qiankun 通过发布订阅模式来实现应用间通信，状态由框架来统一维护，每个应用在初始化时由框架生成一套通信方法，应用通过这些方法来更改全局状态和注册回调函数，全局状态发生改变时触发各个应用注册的回调函数执行，将新旧状态传递到所有应用
