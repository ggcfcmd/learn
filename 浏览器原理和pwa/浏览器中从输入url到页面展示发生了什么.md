# 概览

1. 浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程
2. 在网络进程中发起真正的 URL 请求
3. 网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程
4. 浏览器进程接收到网络进程的响应头数据之后，发送 "提交导航(CommitNavigation)" 消息到渲染进程
5. 渲染进程接收到 "提交导航" 的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道
6. 渲染进程会向浏览器进程 "确认提交"，这意味着告诉浏览器进程准备好接受和解析页面数据了
7. 浏览器进程接收到渲染进程 "提交文档" 的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态

这其中，用户发出 URL 请求到页面开始解析的过程，叫做导航

## 一、用户输入

1. 当用户在地址栏中输入一个查询关键字时，地址栏会判断当前输入的内容是搜索内容还是请求的 URL

· 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎来合成新的带搜索关键字的 URL
· 如果判断输入内容符合 URL 规则，比如www.baidu.com，那么地址栏会根据规则在内容前加上协议，合成完整的URL，比如https://www.baidu.com

2. 执行 beforeunload 事件（用户输入关键字并敲了回车之后意味着当前页面即将要被替换成新的页面，在流程继续之前浏览器会给当前页面一次执行 beforeunload 事件的机会用来允许页面在退出之前执行一些数据清理操作或者询问用户是否要离开当前页面）

## 二、URL 请求过程

浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在其中发起真正的 URL 请求流程

1. 网络进程会查找本地缓存是否缓存了该资源，如果有缓存资源，直接返回资源给浏览器进程

2. 如果在缓存中没有查找到资源，会进入网络请求流程。首先会进行 DNS 解析以获取请求域名的服务器 IP 地址，如果请求协议是 HTTPS，那么还需要建立 TLS 连接。之后建立 TCP 连接，浏览器构建请求行、请求头，并把和该域名相关的 Cookie 等数据附加到请求头中，向服务器发送构建的请求信息

3. 服务器收到请求信息后，会根据请求信息生成响应数据，并发给网络进程，通过 Content-Type 字段告诉浏览器返回的响应体数据是什么类型，不同类型对应着后续不同的处理流程。如果是下载类型，请求会被移交给浏览器的下载管理器，同时该 URL 请求的导航流程到此结束，如果是 html 类型，浏览器会继续导航流程（准备渲染进程渲染页面）

## 三、准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，即每打开一个新页面就会配套创建一个新的渲染进程，但如果符合"单一站点"（根域名和协议相同）原则，浏览器就会让多个页面运行在同一个渲染进程中（Chrome 的默认策略是每个标签对应一个渲染进程，如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，新页面会服用父页面的渲染进程）

## 四、提交文档

这个阶段浏览器进程会将网络进程接收到的 HTML 数据提交给渲染进程

1. 浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起"提交文档"的消息

2. 渲染进程接收到 "提交文档" 的消息后，会和网络进程建立传输数据的 "管道"

3. 等文档数据传输完成之后，渲染进程会返回 "确认提交" 的消息给浏览器进程

4. 浏览器进程在收到 "确认提交" 的消息后，会更新浏览器界面状态，包括安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面

## 五、渲染阶段

1. 构建 DOM 树（浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构，即 DOM 树）

2. 样式计算

本阶段的目的是为了计算出 DOM 节点中每个元素的具体样式

2.1 将 CSS 转换为浏览器能够理解的结构，当渲染引擎接收到 CSS 文本时，会将 CSS 文本转换为浏览器可以理解的结构 -- styleSheets

CSS 样式来源主要有三种
· 通过 link 标签引用的外部 CSS 文件
· <style>标记内的 CSS
· 元素的 style 属性内嵌 CSS（行内样式）

2.2 将样式表中的属性值转换为渲染引擎容易理解的、标准化的计算值

eg：
body { font-size: 2em } -> body { font-size: 32px }
p { color: blue } -> p { color: rgb(0, 0, 255) }

2.3 基于 CSS 的继承、层叠规则计算出 DOM 树中每个节点的具体样式

3. 布局

得到带样式的 DOM 树之后，需要计算出 DOM 树中可见元素的几何位置

3.1 创建布局树（只包含可见元素）

3.2 布局计算

4. 分层

浏览器的页面实际上被分成了许多图层，这些图层互相叠加后合成了最终的页面。渲染引擎需要为特定的节点生成专用的图层，最终构建出一个图层树。并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层

· 拥有层叠上下文属性的元素会被提升为单独的一层
· 需要裁剪的地方会被创建为图层

5. 图层绘制

图层树构建完了之后，渲染引擎会对图层树中的每个图层进行绘制，先将一个图层额绘制拆分成很多小的绘制指令，再把这些指令按照顺序组成一个待绘制列表

6. 栅格化

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，合成线程会将图层划分为图块，然后按照视口附近的图块来优先生成位图，实际生成位图的操作由栅格化来执行（所谓栅格化，就是指将图块转换为位图）

7. 显示

所有的图块都被光栅化之后，合成线程就会生成一个绘制图块的命令 -- "DrawQuad"，然后将该命令提交给浏览器进程，浏览器进程中有一个叫 viz 的组件，用来接收合成线程发来的 DrawQuad 命令，根据命令将页面内容绘制到内存中，最后再将内存显示在屏幕上
