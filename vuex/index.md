# 状态管理工具

## 什么是状态？

前端发展到今天，主流模式是 UI=f(state)，视图通过底层框架（vue、react 等提供的能力，即响应式）根据状态进行驱动，状态在某一时刻的快照对应视图的某一个状态

从广义的角度来看，状态本质上是一种可以描述视图状态、行为的数据结构，状态的管理则是通过一定的算法将这些数据结构组织、管理起来，又回到了 程序 = 数据结构 + 算法 这一基本概念，狭义的角度，状态就是一个值，实际业务场景中，这个值可能是一直在改变的，随之而来的就是视图的更新

## 为什么要管理？

状态又分为 本地状态 和 共享状态

本地状态通常维护在组件内部，而当一些状态被多个不相关的组件应用或者嵌套层级很深导致无法很好的通过组件间通信的状态流进行维护的时候，你自然而然的就会想到使用状态管理工具来维护这些 "共享状态"

## 怎么去管理？

状态管理的方式分为 中心化 和 去中心化 两种模式

### 中心化

Vuex 和 Redux 都是基于 Flux 架构思想设计的，即应用的状态被集中存放到一个仓库中，但是仓库中的状态不能被直接修改，必须通过特定的方式才能更新

开发场景中面临最多的场景是状态重复但不集中，不同的组件依赖了同样的状态，重复就会导致不对等的风险，基于 FLUX 的思想，将采用中心化的状态管理工具，也就是集中式存储管理应用的所有组件的状态，通俗点说就是将所有的状态放在一片全局内存（再通俗点就是对象 ^-^）中，这样可以有效避免重复的问题，也更好地实现了状态和视图层的解耦

### 如何更改状态

FLUX 推崇一种可预测的方式发生变化，并保证有且只有一种更改状态的方式，其好处是所有的变更行为都是可预测的，便于测试及发现问题，甚至可以回到上个状态（类似时间旅行）

# Vuex

## Vuex 如何应用到局部组件中

由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是使用计算属性

## State 单一状态树

用一个对象就包含了全部的应用层级状态，即每个应用仅包含一个 store 对象实例。这样能够使开发人员直接地定位任一特定的状态片段，在调试过程中也能轻易地取得整个当前应用状态的快照

## Getter

当多个不相关组件都需要返回同一个状态的二次处理格式结果时，使用 getter 将处理结果缓存起来，相当于 store 的计算属性

## Mutations

Vuex 中 唯一更改 store 中状态的方式就是提交 mutations store.commit('mutations')

· 必须是同步函数：为了更明确地追踪状态的变化，当使用 devtools 查看 mutations 日志时，每条数据被记录，devtools 都需要捕获到前一状态和后一状态的快照，而任何在回调函数中进行的状态变更都是不可追踪的，违背了其设计的初衷

· 既然 Vuex 中的 store 是响应式的，那在变更状态时，监听状态的 Vue 组件也会自动更新，所以在 mutations 中的操作也需要遵循 Vue 的响应式规则

1. 最好提前在你的 store 中初始化好所有所需属性
2. 当需要在对象上添加新属性时，使用 Vue.set()或者以新对象替换旧对象 state.obj = { ...state.obj, newProp: 123 }

## Actions

通过 store.dispatch('actions')触发

· actions 只是提交 mutation，而不是直接变更状态
· actions 可以包含异步操作
